# 寻路
## 二叉堆
二叉堆是一种特殊的堆，二叉堆是完全二元树（二叉树）或者是近似完全二元树（二叉树）。二叉堆有两种：最大堆和最小堆。最大堆：父结点的键值总是大于或等于任何一个子节点的键值；最小堆：父结点的键值总是小于或等于任何一个子节点的键值。
### 存储
二叉堆一般用数组来表示。如果根节点在数组中的位置是1，第n个位置的子节点分别在2n和 2n+1。因此，第1个位置的子节点在2和3，第2个位置的子节点在4和5。以此类推。这种基于1的数组存储方式便于寻找父节点和子节点。
如果存储数组的下标基于0，那么下标为i的节点的子节点是2i+ 1与2i+ 2；其父节点的下标是⌊floor((i− 1) ∕ 2)⌋。函数floor(x)的功能是“向下取整”，或者说“向下舍入”，即取不大于x的最大整数（与“四舍五入”不同，向下取整是直接取按照数轴上最接近要求值的左边值，即不大于要求值的最大的那个值）。比如floor(1.1)、floor(1.9)都返回1。

对于一个很大的堆，这种存储是低效的。因为节点的子节点很可能在另外一个内存页中。B-heap是一种效率更高的存储方式，把每个子树放到同一内存页。
如果用指针链表存储堆，那么需要能访问叶节点的方法。可以对二叉树“穿线”(threading)方式，来依序遍历这些节点
### 二叉堆的编程实现
#### 算法实现
这里以最小堆为例讲解算法
假设这里要将一组无序整数构建到一棵最小堆里面去; {3, 5, 9, 1, 10, 8, 2, 12, 7, 4}

#### 算法说明：
首先最小堆的特性有, 规则一堆顶(二叉堆的根节点)为此堆中最小元素, 规则二每个节点的值大于其左右两节点的值, 针对同一组被构建的数据集合, 第一点规则下来, 确保跟节点的元素必定是固定的某一个值, 但是第二个规则下, 除了跟节点外的其他节点可能不同的构建算法最后得到的树是不一样的(具体哪个元素在哪个节点上); 规则二下, 我们发现树的左右子节点是无差别的;

## A* 算法
此算法只能够找最到接近最短路径的次优解，算法复杂度较低。

## Dijkstra 算法

Dijkstra算法是针对单源点求最短路径的算法。

其主要思路如下：

1. 将顶点分为两部分：已经知道当前最短路径的顶点集合Q和无法到达顶点集合R。

2. 定义一个距离数组（distance）记录源点到各顶点的距离，下标表示顶点，元素值为距离。源点（start）到自身的距离为0，源点无法到达的顶点的距离就是一个大数（比如Infinity）。

3. 以距离数组中值为非Infinity的顶点V为中转跳点，假设V跳转至顶点W的距离加上顶点V至源点的距离还小于顶点W至源点的距离，那么就可以更新顶点W至源点的距离。即下面distance[V] + matrix[V][W] < distance[W]，那么distance[W] = distance[V] + matrix[V][W]。

4. 重复上一步骤，即遍历距离数组，同时无法到达顶点集合R为空。

此算法能够找到最短路径，算法复杂度高。


### Dijkstra算法和A*算法的比较

Dijkstra算法和A*算法都是最短路径问题的常用算法，下面就对这两种算法的特点进行一下比较。
1.Dijkstra算法计算源点到其他所有点的最短路径长度，A*关注点到点的最短路径(包括具体路径)。
2.Dijkstra算法建立在较为抽象的图论层面，A*算法可以更轻松地用在诸如游戏地图寻路中。
3.Dijkstra算法的实质是广度优先搜索，是一种发散式的搜索，所以空间复杂度和时间复杂度都比较高。对路径上的当前点，A*算法不但记录其到源点的代价，还计算当前点到目标点的期望代价，是一种启发式算法，也可以认为是一种深度优先的算法。
4.由第一点，当目标点很多时，A*算法会带入大量重复数据和复杂的估价函数，所以如果不要求获得具体路径而只比较路径长度时，Dijkstra算法会成为更好的选择。